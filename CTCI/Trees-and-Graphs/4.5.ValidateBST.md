## Validate BST

Implement a function to check if a binary tree is a binary search tree.

#### Solution

We can implement this solution in two different ways. The first leverages the in-order traversal, 
and the second builds off the property that **left <= current < right**.

#### Solution #1. In-Order Traversal

Our first thought might be to do an in-order traversal, copy the elements to an array, and then check to see
if the array is sorted. This solution takes up a bit of extra memory, but it works -- mostly. <br />

The only problem is that it can't handle duplicate values in the tree properly. For example, the algorithm
cannot distinguish between the two trees below (one of which is invalid) since they have the same in-order traversal.

<img width="504" alt="Screen Shot 2019-09-14 at 4 46 28 AM" src="https://user-images.githubusercontent.com/46575719/64907021-47d99a80-d6a2-11e9-8483-20766b61ffaa.png">

However, if we assume that the tree cannot have duplicate values, then this approach works. The pseudocode for this method looks something like:

```java
int index = 0;
void copyBST(TreeNode root, int[] array) {
  if(root == null) return;
  copyBST(root.left, array);
  array[index] = root.data;
  index++;
  copyBST(root.right, array);
}

boolean checkBST(TreeNode root) {
  int[] array = new int[root.size];
  copyBST(root, array);
  for (int i = 1; i< array.length; i++) {
    if(array[i] <= array[i-1] return false;
  }
  return true;
}

```

Note that it is necessary to keep track of the logical "end" of the array, since it would be allocated to 
hold all the elements. <br />

When we examine this solution, we find that the array is not actually necessary. We never use it other than to compare an element to the previous element. So why not just track the last element we saw and compare it as we go? <br />

The code below implements this algorithm:
```java
Integer last_printed = null;
boolean checkBST(TreeNode n) {
  if(n == null) return true;
  
  // Check / recurse left
  if ( !checkBST(n.left)) return false;
  
  // Check current 
  if (last_printed != null && n.data <= data <= last_printed) {
    return false;
  }
  last_printed = n.data;
  
  // Check / recurse right
  if( !checkBST(n.right)) return false;
  
  return true; //All good!
}

```
We've used an *Integer* instead of *int* so that we can know when *last_printed* has been set to a value. <br />
If you don't like the use of static variables, then you can tweak this code to use a wrapper class for the integer, as shown below: 
```java
class WrapInt {
  print int value;
}
```
Or, if you're implementing this in C++ or another language that supports passing integers by reference, then you can simply do that. 




